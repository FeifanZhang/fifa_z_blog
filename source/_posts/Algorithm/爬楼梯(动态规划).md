---
title: 爬楼梯(动态规划)
toc: true
tags:
  - python
  - algorithm
  - dynamic_programing
categories:
  - - algorithm
    - dynamic_programing
date: 2021-09-05 17:21:09
---
# 爬楼梯
## 题目简介
假设你正在爬楼梯。需要 n 阶你才能到达楼顶，每次可以爬 1 或 2 个台阶，有几种不同的方法可以爬到楼顶呢？
## 算法思路
首先，我们先看看爬到第 3 阶台阶会有几种方法：因为每次可以爬 1 或 2 个台阶，所以有两个途径：
1. 从第 2 层迈一步到达第 3 层
2. 从第 1 层迈两步到第 3 层  

所以我们需要知道爬到第 2 层、第 1 层有几种途径，并将到达两个台阶的方法数相加即可得出爬到第 3 层的方法数量。  
同理，第 4 阶可以用`爬到第 3 阶 + 爬到第 2 阶的方法`数量实现。  
由此可推断，爬到`第 n 个台阶`的方法，是到达` n-1 个台阶`与` n-2 个台阶`的方法之和  
在代码中，通过`列表dp`表示到达每层阶梯的方法数量，则到达第 i 阶的方法数量是：
```python
dp[i] = dp[i-1] + dp[i-2]
```
推导出公式了，但总得要有个起始值，下面来确定到达`第 0 阶以及第 1 阶`的方法数量（也就是 `dp[0] 与 dp[1]`的取值)  
`dp[1]`好说，只会有 1 种方法到第 1 阶，但第 0 阶呢？  
到达第 2 阶有2种方法（即`dp[2]` = 2）：  
* 直接从平地跨2阶直接到第 2 阶
* 先到第 1 阶， 在到第 2 阶  

所以反推出`dp[0] = dp[2] - dp[1] = 1`，第 0 阶其实无意义，是为了”凑数“，来保证公式`dp[i] = dp[i-1] + dp[i-2]`成立
## 代码实现
```python
def stair(sta_num: int) -> int:
    dp = [0 for i in range(sta_num + 1)]
    dp[0], dp[1] = 1, 1
    for i in range(2, len(dp)):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[-1]
```
# 进阶版爬楼梯
假设你正在爬楼梯，每次最大可跨越stp个台阶，有几种不同的方法可以爬到第n个阶梯呢？
## 算法思路
## 代码实现
```python
# 动态规划爬楼梯
def stair(sta_num: int, stp: int) -> int:
    """

    :param sta_num: 楼梯的总数
    :param stp: 最大可跨阶梯数（该算法的以下注释中，'最大可跨阶梯数' 都以`stp`简称）
    :return: 当最大可跨阶梯数为`stp`时，到达第 `sta_num`阶楼梯方法数量总和
    """

    # 排除异常输入
    '''
    当台阶数量大于stp时，如：
    最大跨3个台阶时，到达第2个阶梯的方法数量
    对于第2阶梯，最大跨越3个台阶与最大跨越2个台阶是一样的
    所以当输入的sta_num小于stp时，让sta_num = stp
    '''
    if sta_num < stp:
        stp = sta_num
    elif stp <= 1:
        return -1

    # 初始化列表
    dp = [0 for _ in range(sta_num + 1)]  # 列表`dp`存储到达每个台阶所对应的方法数量，初始化时所有阶梯到达的方法数量先设为0
    dp[0], dp[1] = 1, 1  # 无论`stp`为多少，到达第0阶与1阶的方法数量是确定的。
    for a in range(2, stp + 1):
        '''
        通过循环 range(stp + 1, len(dp)) 的注释，可得出dp[i] = dp[i-stp:i]
        但当遇到前stp个台阶时，如：
        stp为3时，计算第2阶有几种方法到达
        stp为4时，计算第2、3阶有几种方法到达
        以此类推...
        当stp为n时，计算2 .. n - 1阶有几种方法到达
        不能按照一般方法dp[i] = dp[i-stp:i]进行计算
        发现如下规律：
        stp为3时，第2阶有2种方法到达(dp[0] + dp[1])，stp > 3时，第2阶仍只有2种方法到达
        stp为4时，第3阶有4种方法到达(dp[0] + dp[1] + dp[2])，stp > 4时，第3阶仍只有4种方法到达
        stp为n时，第n - 1阶有`dp[0] + ... + dp[n - 2]`种到达方法，stp > n时，第n - 1阶仍只有`dp[0] + ... + dp[n - 2]`种方法到达
        所以当计算到达第a个台阶的方法，且a < stp时，dp[a] = dp[a - 1] +...+dp[0] = dp[:a]
        '''
        dp[a] = sum(dp[:a])

    # 初始化完毕，开始计算
    for i in range(stp + 1, len(dp)):
        '''
        stp为2时：dp[i] = dp[i-1] + dp[i-2]
        stp为3时：dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
        故推导出如下公式：dp[i] = dp[i - 1] + ... + dp[i - stp] = dp[i-stp:i]
        由于计算dp[i]所需要的是i前面stp个元素的和，所以计算的循环起始位置为stp + 1
        dp中0~stp位如何计算到达对应阶梯的方法数量，参考range(2, stp + 1)的循环注释
        '''
        dp[i] = sum(dp[i-stp:i])

    return dp[-1]
```